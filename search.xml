<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[利用FileReader和FormData实现图片预览和上传]]></title>
    <url>%2F2019%2F05%2F16%2F%E5%88%A9%E7%94%A8FileReader%E5%92%8CFormData%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E9%A2%84%E8%A7%88%E5%92%8C%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[图片预览上传需求，过去都是客户端上传给后端，后端返回 url 前端进行预览。现在可以依赖 FileReader 和 FormData 这两个对象和 JavaScript 处理二进制的能力。 FileReader 文件阅读器FormData 表格数据二进制流 壹、监听表单文件&lt;input type=&quot;file&quot;&gt; input.on.(&#39;change&#39;, preview); 预览预览使用 FileReader 对象来读：12345678910111213141516function preview(e) &#123; var file = e.target.files[0]; var reader = new FileReader(); reader.onloadend = function () &#123; // 图片的 base64 格式, 可以直接当成 img 的 src 属性值 var dataURL = reader.result; var img = new Image(); img.src = dataURL; // 插入到 DOM 中预览 // ... &#125;; reader.readAsDataURL(file); // 读出 base64 &#125; 贰、提交图片文件（二进制文件 非 base64）123456789101112131415/** * dataURL to blob, ref to https://gist.github.com/fupslot/5015897 * @param dataURI * @returns &#123;Blob&#125; */function dataURItoBlob(dataURI) &#123; var byteString = atob(dataURI.split(',')[1]); var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]; var ab = new ArrayBuffer(byteString.length); var ia = new Uint8Array(ab); for (var i = 0; i &lt; byteString.length; i++) &#123; ia[i] = byteString.charCodeAt(i); &#125; return new Blob([ab], &#123;type: mimeString&#125;);&#125; base64转二进制文件123456789101112131415/** * dataURL to blob, ref to https://gist.github.com/fupslot/5015897 * @param dataURI * @returns &#123;Blob&#125; */function dataURItoBlob(dataURI) &#123; var byteString = atob(dataURI.split(',')[1]); var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]; var ab = new ArrayBuffer(byteString.length); var ia = new Uint8Array(ab); for (var i = 0; i &lt; byteString.length; i++) &#123; ia[i] = byteString.charCodeAt(i); &#125; return new Blob([ab], &#123;type: mimeString&#125;);&#125; 叁、构造 FormData 填充二进制文件数据，通过 ajax 的方式进行提交：123456789101112131415161718192021222324252627var fd = new FormData();var blob = dataURItoBlob(dataURL);fd.append('file', blob); $.ajax(&#123; type: 'POST', url: '/upload', data: fd, processData: false, // 不会将 data 参数序列化字符串 contentType: false, // 根据表单 input 提交的数据使用其默认的 contentType xhr: function() &#123; var xhr = new window.XMLHttpRequest(); xhr.upload.addEventListener("progress", function(evt) &#123; if (evt.lengthComputable) &#123; var percentComplete = evt.loaded / evt.total; console.log('进度', percentComplete); &#125; &#125;, false); return xhr; &#125;&#125;).success(function (res) &#123; // 拿到提交的结果&#125;).error(function (err) &#123; console.error(err);&#125;); 注意还有图片 压缩！！！ 利用canvas 在 new 出来的 Image 对象，我们监听它的 onload 事件 按照压缩比例，算出压缩后的图片尺寸 创建 canvas ，尺寸设置成上一步骤算出来的压缩后的图片尺寸 调用 drawImage 方法，把图片绘制到 canvas 中 调用 canvas 的 toDataURL ，取出 base64 格式的数据 后续的传图步骤和上面的原图上传一样123456789101112131415161718192021222324var img = new Image(); img.onload = function () &#123; // 当图片宽度超过 400px 时, 就压缩成 400px, 高度按比例计算 // 压缩质量可以根据实际情况调整 var w = Math.min(400, img.width); var h = img.height * (w / img.width); var canvas = document.createElement('canvas'); var ctx = canvas.getContext('2d'); // 设置 canvas 的宽度和高度 canvas.width = w; canvas.height = h; // 把图片绘制到 canvas 中 ctx.drawImage(img, 0, 0, w, h); // 取出 base64 格式数据 var dataURL = canvas.toDataURL('image/png'); // ...&#125;; img.src = reader.result;]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery基础]]></title>
    <url>%2F2019%2F05%2F16%2FJQuery-%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[个人理解： JQ就是JS各种东西的封装 俗话说你觉得麻烦的东西都已经有人帮你做了 噢耶~ 有两种方法使用第一种：引CDN第二种：下载文件，页面引用 壹、送上DNS地址 新浪1234&lt;head&gt;&lt;script src="https://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js"&gt;&lt;/script&gt;&lt;/head&gt; 百度1234&lt;head&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt; Google CDN1234&lt;head&gt;&lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt; Microsoft CDN1234&lt;head&gt;&lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt; 贰、 JS 和 JQ 的入口函数的不同JQ入口函数1234567$(document).ready(function()&#123; // 执行代码&#125;);或者$(function()&#123; // 执行代码&#125;); JS 入口函数123window.onload = function () &#123; // 执行代码&#125; &nbsp; window.onload $(document).ready 执行时机 必须等待网页全部加载完毕（包括图片等），然后再执行包裹代码 只需要等待网页中的DOM结构加载完毕，就能执行包裹的代码 执行次数 只能执行一次，如果第二次，那么第一次的执行会被覆盖 可以执行多次，第N次都不会覆盖上一次 简写方案 无 $(function(){}); 叁、JQ的事件一个实例123456// 只允许按下的字母键生效, 65~90是所有小写字母的键盘代码范围var validKeys = &#123; start: 65, end: 90 &#125;;$("#keys").keydown( validKeys, function(event)&#123; var keys = event.data; //拿到validKeys对象. return event.which &gt;= keys.start &amp;&amp; event.which &lt;= keys.end;&#125; ); 1.keydown：在键盘上按下某键时发生,一直按着则会不断触发（opera浏览器除外）, 它返回的是键盘代码; 2.keypress：在键盘上按下一个按键，并产生一个字符时发生, 返回ASCII码。注意: shift、alt、ctrl等键按下并不会产生字符，所以监听无效 ,换句话说, 只有按下能在屏幕上输出字符的按键时keypress事件才会触发。若一直按着某按键则会不断触发。 3.keyup：用户松开某一个按键时触发, 与keydown相对, 返回键盘代码. 1234// 获取按键代码或字符的ASCII码$(window).keydown( function(event)&#123; // 通过event.which可以拿到按键代码. 如果是keypress事件中,则拿到ASCII码.&#125; ); 4.获取事件对象 1234567$(document).ready(function()&#123; $(window).keypress(function(event)&#123; //获取事件对象，里面包含各种有用的信息。 console.log(event); //console.log(event.which); &#125;);&#125;); 5.keypress事件获取键入字符 123456$(window).keypress(function(event)&#123; //event.which是获取ASCII码，前面的函数是将ASCII码转换成字符，空格键和Enter键输出均为空白。 console.log(String.fromCharCode(event.which)); //从event对象中key属性获取字符，但是Enter键的key值为"Enter"，空白键还是空白" "。 console.log(event.key);&#125;); 肆、选择器（这个就不多说了，有点css基础就能看懂）不信你点开看看]]></content>
      <tags>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下拉指定位置显示隐藏元素]]></title>
    <url>%2F2019%2F05%2F14%2F%E4%B8%8B%E6%8B%89%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[应用于移动端下拉到某个位置，显示某些元素壹、HTML部分123456&lt;div id="box" class="box"&gt; &lt;div class="son"&gt;&lt;/div&gt; &lt;div id="eBtn" onclick="eBtnClick()" class="e-btn fixed-btn"&gt; &lt;span class="txt"&gt;按钮&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; 贰、JS部分12345678910111213141516171819202122232425262728293031// 引入 JQ&lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt; $(function () &#123; // 绑定滚动条事件 $("#box").bind("scroll", function () &#123; var sTop = $("#box").scrollTop(); var sTop = parseInt(sTop); // 设置显示位置 if (sTop &gt;= 348) &#123; if (!$("#eBtn").is(":visible")) &#123; try &#123; $("#eBtn").slideDown(); &#125; catch (e) &#123; $("#eBtn").show(); &#125; console.log("执行了"); &#125; // console.log(sTop) &#125; else &#123; if ($("#eBtn").is(":visible")) &#123; try &#123; $("#eBtn").slideUp(); &#125; catch (e) &#123; $("#eBtn").hide(); &#125; &#125; &#125; &#125;); &#125;)&lt;/script&gt; 叁、CSS部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;style&gt; html, body &#123; font-family: FZLANTINGHEIPro_04_OPPO--GB1-4, PingFangSC-Regular; margin: 0px; padding: 0px; width: 100%; height: 100%; &#125; body &#123; max-width: 600px; margin: auto; &#125; .box &#123; width: 100%; height: 100%; overflow: scroll; -webkit-overflow-scrolling: touch; line-height: 1.5; &#125; .box .e-btn &#123; height: 44px; line-height: 44px; width: 100%; border-radius: 7.3333px; text-align: center; background: green; border-color: #66b1ff; color: #FFF; &#125; .box .e-btn .txt &#123; font-family: ColorFont-Medium; font-size: 15px; color: #ffffff; letter-spacing: 0; &#125; .box .fixed-btn &#123; position: fixed; /* width: 86.6666%; */ width: 100%; max-width: 600px; left: 0; right: 0; margin: auto; bottom: 5px; z-index: 9999; border-radius: 0px; bottom: 0px; display: none; &#125; .box .son &#123; width: 100%; height: 1600px; background: brown; &#125; &lt;/style&gt; 特别提醒-webkit-overflow-scrolling:touch是什么？ -webkit-overflow-scrolling 属性控制元素在移动设备上是否使用滚动回弹效果.auto: 使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止。touch: 使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文。 在移动端上，在你用overflow-y:scorll属性的时候，你会发现滚动的效果很木，很慢，这时候可以使用-webkit-overflow-scrolling:touch这个属性，让滚动条产生滚动回弹的效果，就像ios原生的滚动条一样流畅。]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于FormData]]></title>
    <url>%2F2019%2F05%2F14%2F%E5%85%B3%E4%BA%8EFormData%2F</url>
    <content type="text"><![CDATA[FormData的主要用途有两个：1. 将form表单元素的name与value进行组合，实现表单数据的序列化，从而减少表单元素的拼接，提高工作效率。2. 异步上传文件壹、创建formData对象1. 创建空对象123456789//通过FormData构造函数创建一个空对象var formdata=new FormData();//可以通过append()方法来追加数据formdata.append("name","laotie");//通过get方法对值进行读取console.log(formdata.get("name"));//laotie//通过set方法对值进行设置formdata.set("name","laoliu");console.log(formdata.get("name"));//laoliu 2. 通过表单对formData进行初始化创建表单：12345678910&lt;form id="advForm"&gt; &lt;p&gt;广告名称：&lt;input type="text" name="advName" value="xixi"&gt;&lt;/p&gt; &lt;p&gt;广告类别：&lt;select name="advType"&gt; &lt;option value="1"&gt;轮播图&lt;/option&gt; &lt;option value="2"&gt;轮播图底部广告&lt;/option&gt; &lt;option value="3"&gt;热门回收广告&lt;/option&gt; &lt;option value="4"&gt;优品精选广告&lt;/option&gt; &lt;/select&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="button" id="btn" value="添加"&gt;&lt;/p&gt;&lt;/form&gt; 通过表单元素作为参数，实现对formData的初始化：12345678910111213//获得表单按钮元素var btn=document.querySelector("#btn");//为按钮添加点击事件btn.onclick=function()&#123; //根据ID获得页面当中的form表单元素 var form=document.querySelector("#advForm"); //将获得的表单元素作为参数，对formData进行初始化 var formdata=new FormData(form); //通过get方法获得name为advName元素的value值 console.log(formdata.get("advName"));//xixi //通过get方法获得name为advType元素的value值 console.log(formdata.get("advType"));//1 &#125; 贰、创建formData对象1. 通过get(key)与getAll(key)来获取相对应的值1234// 获取key为age的第一个值formdata.get("age"); // 获取key为age的所有值，返回值为数组类型formdata.getAll("age"); 2. 通过append(key,value)在数据末尾追加数据123456789101112//通过FormData构造函数创建一个空对象var formdata=new FormData();//通过append()方法在末尾追加key为name值为laoliu的数据formdata.append("name","laoliu");//通过append()方法在末尾追加key为name值为laoli的数据formdata.append("name","laoli");//通过append()方法在末尾追加key为name值为laotie的数据formdata.append("name","laotie");//通过get方法读取key为name的第一个值console.log(formdata.get("name"));//laoliu//通过getAll方法读取key为name的所有值console.log(formdata.getAll("name"));//["laoliu", "laoli", "laotie"] 3. 通过set(key, value)来设置修改数据key的值不存在，会添加一条数据1234//如果key的值不存在会为数据添加一个key为name值为laoliu的数据formdata.set("name","laoli");//通过get方法读取key为name的第一个值console.log(formdata.get("name"));//laoli key的值存在，会修改对应的value值123456//将存在的key为name的值修改为laoliformdata.set("name","laoli");//通过get方法读取key为name的第一个值console.log(formdata.get("name"));//laolis//通过getAll方法读取key为name的所有值console.log(formdata.getAll("name"));//["laoli"] 4. 通过has(key)来判断是否存在对应的key值1234//判断是否包含key为name的数据console.log(formdata.has("name"));//true//判断是否包含key为age的数据console.log(formdata.has("age"));//false 5. 通过delete(key)可以删除数据123//删除key为name的值formdata.delete("name");console.log(formdata.get("name"));//null 叁、通过XMLHttpRequest发送数据1. 创建表单：12345678910111213&lt;form id="advForm"&gt; &lt;p&gt;广告名称：&lt;input type="text" name="advName" value="xixi"&gt;&lt;/p&gt; &lt;p&gt;广告类别：&lt;select name="advType"&gt; &lt;option value="1"&gt;轮播图&lt;/option&gt; &lt;option value="2"&gt;轮播图底部广告&lt;/option&gt; &lt;option value="3"&gt;热门回收广告&lt;/option&gt; &lt;option value="4"&gt;优品精选广告&lt;/option&gt; &lt;/select&gt;&lt;/p&gt; &lt;p&gt;广告图片：&lt;input type="file" name="advPic"&gt;&lt;/p&gt; &lt;p&gt;广告地址：&lt;input type="text" name="advUrl"&gt;&lt;/p&gt; &lt;p&gt;广告排序：&lt;input type="text" name="orderBy"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="button" id="btn" value="添加"&gt;&lt;/p&gt;&lt;/form&gt; 2. 发送数据：123456789101112var btn=document.querySelector("#btn");btn.onclick=function()&#123; var formdata=new FormData(document.getElementById("advForm")); var xhr=new XMLHttpRequest(); xhr.open("post","http://127.0.0.1/adv"); xhr.send(formdata); xhr.onload=function()&#123; if(xhr.status==200)&#123; //... &#125; &#125;&#125;]]></content>
      <tags>
        <tag>关于FormData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于MarkDown语法]]></title>
    <url>%2F2019%2F05%2F09%2F%E5%85%B3%E4%BA%8EMarkDown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[壹、标题等级标题等级标题等级标题等级标题等级标题等级 12345678910用 星号 “ * ” 区分在文字前面加几个星号就是几级标题最多六级``` ### 贰、粗体斜体* *斜体** **粗体*** ***粗斜体*** 斜体 粗体 粗斜体分割线就是 “***” 三个星号即可12345### 叁、列表1. #### 无序列表* 一个 * 号，星号后面加空格 显示实心圆 * 两个空格 再加上一个 * 号 再加一个空格 显示空心圆 （一个空格）内容（两个空格）（一个空格）内容12. #### 有序列表 内容 内容 空格数字. 空格 内容 13. #### 有序和无序也可以混搭 第一级 内容 第二级 内容12345### 肆、引用&gt; 引用&gt;&gt; 引用&gt;&gt;&gt; 引用 引用 引用 引用123### 伍、插入链接1. [这是我github地址！！！](https://github.com/MagnificentSun) 这是我github地址！！！12. ![这是我的突突突！！！](https://stock.tuchong.com/image?fromSimilarSearch=&amp;imageId=238565135354167627&amp;requestId=4fdb11a581af472fa39b799c1a6072a3&amp;searchId=f7aa7d30041d47d79ad19ae591212212&amp;term=%E7%8B%97) 123456### 陆、表格标题1|标题2|标题3- | - | -内容1|内容2|内容3内容1|内容2|内容3 标题1 标题2 标题3 内容1 内容2 内容3 内容1 内容2 内容3 第二行的—|—|— 有几个标题写几个—|—|—|— 这就是有四个标题—|— 这就是有两个标题而且 - 和 | 之间有无空格以及个数（最少一个）没太大限制 可按自己要求调整比如我的例子那么大的缝12345678910111213141516### 一些技巧&gt; 1.换行： 要换行的地方敲（两个空格） 2.首行缩进两个字符： &amp;ensp &amp;emsp#### 今天用到了MarkDown 的字体颜色才知道原来他是 内嵌 HTML &lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt; &lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt; &lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt; &lt;font color=#0099ff size=1 face=&quot;黑体&quot;&gt;color=#0099ff size=7 face=&quot;黑体&quot;&lt;/font&gt; &lt;font color=#00ffff size=2&gt;color=#00ffff&lt;/font&gt; &lt;font color=gray size=3&gt;color=gray&lt;/font&gt; &gt; Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3 代码如下 我是黑体字 我是微软雅黑 我是华文彩云 color=#0099ff size=72 face=”黑体” color=#00ffff color=gray`]]></content>
      <tags>
        <tag>MarkDown语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好,Mr·Sun！]]></title>
    <url>%2F2019%2F04%2F28%2F%E5%85%B3%E4%BA%8E%E4%BD%A0%E5%A5%BD%20Mr%C2%B7Sun%EF%BC%81%2F</url>
    <content type="text"><![CDATA[一上午的倾情打造 我觉得还是有下划线的标题好看 所以我就用了最大 但是我觉得密钥代码好长所以给大家分享福利^_^检查是否由.ssh的文件夹cd ~/.ssh 输入ls，列出该文件下的内容ls 输入ssh-keygen -t rsa -C “929762930@qq.com”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh)ssh-keygen -t rsa -C “*****@qq.com” 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agenteval &quot;$(ssh-agent -s)&quot; 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agentssh-add ~/.ssh/id_rsa 1进入Github，点击头像下的settings，添加ssh 收尾]]></content>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Token的理解]]></title>
    <url>%2F2019%2F04%2F28%2F%E5%85%B3%E4%BA%8EToken%2F</url>
    <content type="text"><![CDATA[1. 首先，先了解一下request和session的区别 request 指在一次请求的全过程中有效，即从http请求到服务器处理结束，返回响应的整个过程，存放在HttpServletRequest对象中。在这个过程中可以使用forward方式跳转多个jsp。在这些页面里你都可以使用这个变量。request是用户请求访问的当前组件，以及和当前web组件共享同一用户请求的web组件。如：被请求的jsp页面和该页面用指令包含的页面以及标记包含的其它jsp页面；Session是用户全局变量，在整个会话期间都有效。只要页面不关闭就一直有效（或者直到用户一直未活动导致会话过期，默认session过期时间为30分钟，或调用HttpSession的invalidate()方法）。存放在HttpSession对象中 ，同一个http会话中的web组件共享它。 2. token主要有两个作用: ①:防止表单重复提交(防止表单重复提交一般还是使用前后端都限制的方式，比如：在前端点击提交之后，将按钮置为灰色，不可再次点击，然后客户端和服务端的token各自独立存储，客户端存储在Cookie或者Form的隐藏域（放在Form隐藏域中的时候，需要每个表单）中，服务端存储在Session（单机系统中可以使用）或者其他缓存系统（分布式系统可以使用）中。)②：用来作身份验证 3. token主要有两个作用: 主要的理念是，客户端初始化的时候，一般就是刚刚进入页面的时候就调用后端代码，后端代码生成一个token,返回给客户端，客户端储存token（可以在前台使用Form表单中使用隐藏域来存储这个Token，也可以使用cookie）,然后就将request(请求)中的token与（session）中的token进行比较; 4. 使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的: 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据]]></content>
      <tags>
        <tag>Token</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
