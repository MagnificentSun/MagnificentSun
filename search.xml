<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于FormData]]></title>
    <url>%2F2019%2F05%2F14%2F%E5%85%B3%E4%BA%8EFormData%2F</url>
    <content type="text"><![CDATA[FormData的主要用途有两个：1. 将form表单元素的name与value进行组合，实现表单数据的序列化，从而减少表单元素的拼接，提高工作效率。2. 异步上传文件壹、创建formData对象1. 创建空对象123456789//通过FormData构造函数创建一个空对象var formdata=new FormData();//可以通过append()方法来追加数据formdata.append("name","laotie");//通过get方法对值进行读取console.log(formdata.get("name"));//laotie//通过set方法对值进行设置formdata.set("name","laoliu");console.log(formdata.get("name"));//laoliu 2. 通过表单对formData进行初始化创建表单：12345678910&lt;form id="advForm"&gt; &lt;p&gt;广告名称：&lt;input type="text" name="advName" value="xixi"&gt;&lt;/p&gt; &lt;p&gt;广告类别：&lt;select name="advType"&gt; &lt;option value="1"&gt;轮播图&lt;/option&gt; &lt;option value="2"&gt;轮播图底部广告&lt;/option&gt; &lt;option value="3"&gt;热门回收广告&lt;/option&gt; &lt;option value="4"&gt;优品精选广告&lt;/option&gt; &lt;/select&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="button" id="btn" value="添加"&gt;&lt;/p&gt;&lt;/form&gt; 通过表单元素作为参数，实现对formData的初始化：12345678910111213//获得表单按钮元素var btn=document.querySelector("#btn");//为按钮添加点击事件btn.onclick=function()&#123; //根据ID获得页面当中的form表单元素 var form=document.querySelector("#advForm"); //将获得的表单元素作为参数，对formData进行初始化 var formdata=new FormData(form); //通过get方法获得name为advName元素的value值 console.log(formdata.get("advName"));//xixi //通过get方法获得name为advType元素的value值 console.log(formdata.get("advType"));//1 &#125; 贰、创建formData对象1. 通过get(key)与getAll(key)来获取相对应的值1234// 获取key为age的第一个值formdata.get("age"); // 获取key为age的所有值，返回值为数组类型formdata.getAll("age"); 2. 通过append(key,value)在数据末尾追加数据123456789101112//通过FormData构造函数创建一个空对象var formdata=new FormData();//通过append()方法在末尾追加key为name值为laoliu的数据formdata.append("name","laoliu");//通过append()方法在末尾追加key为name值为laoli的数据formdata.append("name","laoli");//通过append()方法在末尾追加key为name值为laotie的数据formdata.append("name","laotie");//通过get方法读取key为name的第一个值console.log(formdata.get("name"));//laoliu//通过getAll方法读取key为name的所有值console.log(formdata.getAll("name"));//["laoliu", "laoli", "laotie"] 3. 通过set(key, value)来设置修改数据key的值不存在，会添加一条数据1234//如果key的值不存在会为数据添加一个key为name值为laoliu的数据formdata.set("name","laoli");//通过get方法读取key为name的第一个值console.log(formdata.get("name"));//laoli key的值存在，会修改对应的value值123456//将存在的key为name的值修改为laoliformdata.set("name","laoli");//通过get方法读取key为name的第一个值console.log(formdata.get("name"));//laolis//通过getAll方法读取key为name的所有值console.log(formdata.getAll("name"));//["laoli"] 4. 通过has(key)来判断是否存在对应的key值1234//判断是否包含key为name的数据console.log(formdata.has("name"));//true//判断是否包含key为age的数据console.log(formdata.has("age"));//false 5. 通过delete(key)可以删除数据123//删除key为name的值formdata.delete("name");console.log(formdata.get("name"));//null 叁、通过XMLHttpRequest发送数据1. 创建表单：12345678910111213&lt;form id="advForm"&gt; &lt;p&gt;广告名称：&lt;input type="text" name="advName" value="xixi"&gt;&lt;/p&gt; &lt;p&gt;广告类别：&lt;select name="advType"&gt; &lt;option value="1"&gt;轮播图&lt;/option&gt; &lt;option value="2"&gt;轮播图底部广告&lt;/option&gt; &lt;option value="3"&gt;热门回收广告&lt;/option&gt; &lt;option value="4"&gt;优品精选广告&lt;/option&gt; &lt;/select&gt;&lt;/p&gt; &lt;p&gt;广告图片：&lt;input type="file" name="advPic"&gt;&lt;/p&gt; &lt;p&gt;广告地址：&lt;input type="text" name="advUrl"&gt;&lt;/p&gt; &lt;p&gt;广告排序：&lt;input type="text" name="orderBy"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="button" id="btn" value="添加"&gt;&lt;/p&gt;&lt;/form&gt; 2. 发送数据：123456789101112var btn=document.querySelector("#btn");btn.onclick=function()&#123; var formdata=new FormData(document.getElementById("advForm")); var xhr=new XMLHttpRequest(); xhr.open("post","http://127.0.0.1/adv"); xhr.send(formdata); xhr.onload=function()&#123; if(xhr.status==200)&#123; //... &#125; &#125;&#125;]]></content>
      <tags>
        <tag>关于FormData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于MarkDown语法]]></title>
    <url>%2F2019%2F05%2F09%2F%E5%85%B3%E4%BA%8EMarkDown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、标题等级标题等级标题等级标题等级标题等级标题等级 12345678910用 星号 “ * ” 区分在文字前面加几个星号就是几级标题最多六级``` # 二、粗体斜体* *斜体** **粗体*** ***粗斜体*** 斜体 粗体 粗斜体分割线就是 “***” 三个星号即可12345# 三、列表1. #### 无序列表* 一个 * 号，星号后面加空格 显示实心圆 * 两个空格 再加上一个 * 号 再加一个空格 显示空心圆 （一个空格）内容（两个空格）（一个空格）内容12. #### 有序列表 内容 内容 空格数字. 空格 内容 13. #### 有序和无序也可以混搭 第一级 内容 第二级 内容12345# 四、引用&gt; 引用&gt;&gt; 引用&gt;&gt;&gt; 引用 引用 引用 引用123# 五、插入链接1. [这是我github地址！！！](https://github.com/MagnificentSun) 这是我github地址！！！12. ![这是我的突突突！！！](https://stock.tuchong.com/image?fromSimilarSearch=&amp;imageId=238565135354167627&amp;requestId=4fdb11a581af472fa39b799c1a6072a3&amp;searchId=f7aa7d30041d47d79ad19ae591212212&amp;term=%E7%8B%97) 123456# 六、表格标题1|标题2|标题3- | - | -内容1|内容2|内容3内容1|内容2|内容3 标题1 标题2 标题3 内容1 内容2 内容3 内容1 内容2 内容3 第二行的—|—|— 有几个标题写几个—|—|—|— 这就是有四个标题—|— 这就是有两个标题而且 - 和 | 之间有无空格以及个数（最少一个）没太大限制 可按自己要求调整比如我的例子那么大的缝`]]></content>
      <tags>
        <tag>MarkDown语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好,Mr·Sun！]]></title>
    <url>%2F2019%2F04%2F28%2F%E5%85%B3%E4%BA%8E%E4%BD%A0%E5%A5%BD%20Mr%C2%B7Sun%EF%BC%81%2F</url>
    <content type="text"><![CDATA[一上午的倾情打造 我觉得还是有下划线的标题好看 所以我就用了最大 但是我觉得密钥代码好长所以给大家分享福利^_^检查是否由.ssh的文件夹cd ~/.ssh 输入ls，列出该文件下的内容ls 输入ssh-keygen -t rsa -C “929762930@qq.com”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh)ssh-keygen -t rsa -C “*****@qq.com” 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agenteval &quot;$(ssh-agent -s)&quot; 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agentssh-add ~/.ssh/id_rsa 1进入Github，点击头像下的settings，添加ssh 收尾]]></content>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Token的理解]]></title>
    <url>%2F2019%2F04%2F28%2F%E5%85%B3%E4%BA%8EToken%2F</url>
    <content type="text"><![CDATA[1. 首先，先了解一下request和session的区别 request 指在一次请求的全过程中有效，即从http请求到服务器处理结束，返回响应的整个过程，存放在HttpServletRequest对象中。在这个过程中可以使用forward方式跳转多个jsp。在这些页面里你都可以使用这个变量。request是用户请求访问的当前组件，以及和当前web组件共享同一用户请求的web组件。如：被请求的jsp页面和该页面用指令包含的页面以及标记包含的其它jsp页面；Session是用户全局变量，在整个会话期间都有效。只要页面不关闭就一直有效（或者直到用户一直未活动导致会话过期，默认session过期时间为30分钟，或调用HttpSession的invalidate()方法）。存放在HttpSession对象中 ，同一个http会话中的web组件共享它。 2. token主要有两个作用: ①:防止表单重复提交(防止表单重复提交一般还是使用前后端都限制的方式，比如：在前端点击提交之后，将按钮置为灰色，不可再次点击，然后客户端和服务端的token各自独立存储，客户端存储在Cookie或者Form的隐藏域（放在Form隐藏域中的时候，需要每个表单）中，服务端存储在Session（单机系统中可以使用）或者其他缓存系统（分布式系统可以使用）中。)②：用来作身份验证 3. token主要有两个作用: 主要的理念是，客户端初始化的时候，一般就是刚刚进入页面的时候就调用后端代码，后端代码生成一个token,返回给客户端，客户端储存token（可以在前台使用Form表单中使用隐藏域来存储这个Token，也可以使用cookie）,然后就将request(请求)中的token与（session）中的token进行比较; 4. 使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的: 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据]]></content>
      <tags>
        <tag>Token</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
